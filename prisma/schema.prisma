generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum MessageRole {
  user
  assistant
  system
}

enum ModelTier {
  free
  standard
  premium
}

enum ModelDeveloper {
  openai
  anthropic
  google
  meta
  deepseek
  mistral
}

enum ModelProvider {
  openrouter
  openai
  anthropic
  google
  meta
  deepseek
  mistral
}

// Better Auth: core tables for credentials and session
model User {
  id            String          @id @default(cuid())
  email         String          @unique
  emailVerified Boolean         @default(false)
  name          String?
  image         String?
  locale        String?         @default("en")
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  sessions      Session[]
  accounts      Account[]
  conversations Conversation[]
  tokenUsages   TokenUsage[]
  piiDetectionCosts PiiDetectionCost[]
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId              String
  providerId             String
  accessToken            String?
  refreshToken           String?
  accessTokenExpiresAt   DateTime?
  refreshTokenExpiresAt  DateTime?
  scope                  String?
  idToken                String?
  password               String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
}

// AI Model catalog
model AiModel {
  id               String          @id
  name             String
  developer        ModelDeveloper
  provider         ModelProvider
  descriptionShort String?
  descriptionLong  String?         @db.Text
  throughput       Int?            // tok/s
  latency          Int?            // ms
  contextWindow    Int
  inputCostPer1M   Int             // micro-USD
  outputCostPer1M  Int             // micro-USD
  tier             ModelTier
  archived         Boolean         @default(false)
  enabled          Boolean         @default(true)
  sortOrder        Int
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  capabilities     ModelCapability[]
  messages         Message[]
  conversations    Conversation[]

  @@index([enabled, archived])
}

model ModelCapability {
  id     String    @id
  name   String    @unique
  models AiModel[]
}

// AI Chat: conversations, messages, and token usage tracking
model Conversation {
  id          String    @id @default(cuid())
  userId      String
  title       String    // From first user message, max 50 chars
  modelId     String    @default("openai/gpt-4o-mini")
  totalTokens Int       @default(0)
  totalCost   Int       @default(0)  // micro-USD
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  aiModel     AiModel   @relation(fields: [modelId], references: [id])
  messages    Message[]
  piiDetectionCosts PiiDetectionCost[]

  @@index([userId])
  @@index([createdAt])
  @@index([userId, deletedAt])
}

model Message {
  id                       String         @id @default(cuid())
  conversationId           String
  role                     MessageRole
  content                  String         @db.Text
  modelId                  String?        // OpenRouter model ID (null for user messages)
  tokenCount               Int            @default(0)
  cost                     Int            @default(0)  // micro-USD
  inputCostPer1MSnapshot   Int?           // micro-USD at time of send
  outputCostPer1MSnapshot  Int?
  position                 Int            // ordering within conversation
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  deletedAt                DateTime?
  conversation             Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  aiModel                  AiModel?       @relation(fields: [modelId], references: [id], onDelete: SetNull)
  piiDetections            PiiDetection[]

  @@unique([conversationId, position])
  @@index([conversationId])
  @@index([createdAt])
  @@index([conversationId, deletedAt])
}

// PII detection metadata for audit; never stores original PII values
model PiiDetection {
  id          String   @id @default(cuid())
  messageId   String
  piiType     String   // e.g. email, phone, ssn, credit_card, address, full_name, gov_id, ip, dob
  startOffset Int      // character offset in message content
  endOffset   Int      // character offset (exclusive)
  placeholder String   // e.g. "[EMAIL]", "[PHONE]"
  detectedAt  DateTime @default(now())
  confidence  Float?   // 0â€“1 if provided by detection service
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([messageId, piiType])
  @@index([detectedAt])
  @@index([piiType])
}

model TokenUsage {
  id          String   @id @default(cuid())
  userId      String
  date        DateTime @db.Date // Daily aggregate, date only
  totalTokens Int      @default(0)
  totalCost   Int      @default(0)  // micro-USD
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}

// PII detection cost tracking (separate from user token quotas)
model PiiDetectionCost {
  id             String       @id @default(cuid())
  userId         String?      // Optional: track per user
  conversationId String?      // Optional: track per conversation
  date           DateTime     @db.Date // Daily aggregate, date only
  requestCount   Int          @default(0) // Number of API calls
  totalTokens    Int          @default(0) // Total tokens used
  totalLatencyMs Int          @default(0) // Total latency in milliseconds
  errorCount     Int          @default(0) // Number of errors
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  user           User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId, date])
  @@index([userId])
  @@index([conversationId])
  @@index([date])
}
