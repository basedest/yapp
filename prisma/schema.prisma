generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Better Auth: core tables for credentials and session
model User {
  id            String          @id @default(cuid())
  email         String          @unique
  emailVerified Boolean         @default(false)
  name          String?
  image         String?
  locale        String?         @default("en")
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  sessions      Session[]
  accounts      Account[]
  conversations Conversation[]
  tokenUsages   TokenUsage[]
  piiDetectionCosts PiiDetectionCost[]
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId              String
  providerId             String
  accessToken            String?
  refreshToken           String?
  accessTokenExpiresAt   DateTime?
  refreshTokenExpiresAt  DateTime?
  scope                  String?
  idToken                String?
  password               String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
}

// AI Chat: conversations, messages, and token usage tracking
model Conversation {
  id          String    @id @default(cuid())
  userId      String
  title       String    // From first user message, max 50 chars
  totalTokens Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages    Message[]
  piiDetectionCosts PiiDetectionCost[]

  @@index([userId])
  @@index([createdAt])
}

model Message {
  id             String         @id @default(cuid())
  conversationId String
  role           String         // "user" | "assistant" | "system"
  content        String         @db.Text
  tokenCount     Int            @default(0)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  piiDetections  PiiDetection[]

  @@index([conversationId])
  @@index([createdAt])
}

// PII detection metadata for audit; never stores original PII values
model PiiDetection {
  id          String   @id @default(cuid())
  messageId   String
  piiType     String   // e.g. email, phone, ssn, credit_card, address, full_name, gov_id, ip, dob
  startOffset Int      // character offset in message content
  endOffset   Int      // character offset (exclusive)
  placeholder String   // e.g. "[EMAIL]", "[PHONE]"
  detectedAt  DateTime @default(now())
  confidence  Float?   // 0â€“1 if provided by detection service
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([messageId, piiType])
  @@index([detectedAt])
  @@index([piiType])
}

model TokenUsage {
  id          String   @id @default(cuid())
  userId      String
  date        DateTime @db.Date // Daily aggregate, date only
  totalTokens Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}

// PII detection cost tracking (separate from user token quotas)
model PiiDetectionCost {
  id             String       @id @default(cuid())
  userId         String?      // Optional: track per user
  conversationId String?      // Optional: track per conversation
  date           DateTime     @db.Date // Daily aggregate, date only
  requestCount   Int          @default(0) // Number of API calls
  totalTokens    Int          @default(0) // Total tokens used
  totalLatencyMs Int          @default(0) // Total latency in milliseconds
  errorCount     Int          @default(0) // Number of errors
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  user           User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId, date])
  @@index([userId])
  @@index([conversationId])
  @@index([date])
}
